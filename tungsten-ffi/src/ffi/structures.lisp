(in-package :ffi)

(defclass foreign-structure (foreign-type)
  ((members
    :type list
    :initarg :members
    :reader foreign-structure-members)))

(defclass foreign-structure-member ()
  ((name
    :type symbol
    :initarg :name
    :reader foreign-structure-member-name)
   (type
    :type symbol
    :initarg :type
    :reader foreign-structure-member-type)
   (count
    :type (integer 1)
    :initarg :count
    :initform 1
    :reader foreign-structure-member-count)
   (offset
    :type (integer 0)
    :initarg :offset
    :reader foreign-structure-member-offset)))

(define-condition unknown-foreign-structure-member (error)
  ((foreign-structure
    :type foreign-structure
    :initarg :foreign-structure)
   (name
    :type symbol
    :initarg :name))
  (:report
   (lambda (condition stream)
     (with-slots (name foreign-structure) condition
       (format stream "Unknown foreign structure member ~S in ~A."
               name foreign-structure)))))

(defmethod print-object ((member foreign-structure-member) stream)
  (print-unreadable-object (member stream :type t)
    (princ (foreign-structure-member-name member) stream)))

(defmethod initialize-instance :after ((struct foreign-structure)
                                       &key &allow-other-keys)
  (let ((offset 0)
        (max-alignment 0))
    ;; Compute the offset of each member
    (dolist (member (foreign-structure-members struct))
      (with-slots (name type count) member
        (let ((alignment (foreign-type-alignment type)))
          (setf max-alignment (max max-alignment alignment))
          (cond
            ((slot-boundp member 'offset)
             (let ((member-offset (foreign-structure-member-offset member)))
               (when (< member-offset offset)
                 (error "invalid offset ~D for member ~S" member-offset name))
               (setf offset member-offset)))
            (t
             (unless (zerop (mod offset alignment))
               (incf offset
                     (- alignment (mod offset alignment))))
             (setf (slot-value member 'offset) offset))))
        (incf offset (* (foreign-type-size type) count))))
    ;; Compute the size of the structure; it must be a multiple of the
    ;; alignment of the structure itself, which is the largest member
    ;; alignment. This is true at least on x86_64.
    (let ((size offset))
      (unless (zerop (mod size max-alignment))
        (incf size (- max-alignment (mod size max-alignment))))
      (unless (slot-boundp struct 'size)
        (setf (slot-value struct 'size) size))
      (unless (slot-boundp struct 'alignment)
        (setf (slot-value struct 'alignment) max-alignment)))
    (setf (slot-value struct 'base-type) :pointer)))

(defun find-foreign-structure-member (name struct)
  (or (find name (foreign-structure-members struct)
            :key #'foreign-structure-member-name)
      (error 'unknown-foreign-structure-member :struct struct :name name)))

(defmacro define-foreign-structure ((name &key size sort-members)
                                    (&rest members-data))
  ;; For structures defined in code generated by the extractor, we do not know
  ;; the order in which members are laid out; we generate the offset of each
  ;; member but cannot reorder them. So we do it here if SORT-MEMBERS it not
  ;; null.
  (let* ((members (gensym "MEMBERS-"))
         (member-forms
           (mapcar
            (lambda (member-data)
              (destructuring-bind (name type &key (count 1) offset)
                  member-data
                `(make-instance 'foreign-structure-member
                                :name ,name
                                :type ,type
                                :count ,count
                                ,@(when offset (list :offset offset)))))
            members-data)))
    `(let ((,members (list ,@member-forms)))
       ,(when sort-members
          `(setf ,members
                 (sort ,members
                       (lambda (member1 member2)
                         (and (slot-boundp member1 'offset)
                              (slot-boundp member2 'offset)
                              (< (slot-value member1 'offset)
                                 (slot-value member2 'offset)))))))
       (register-foreign-type
        (make-instance 'foreign-structure
                       :name ',name
                       ,@(when size `(:size ,size))
                       :members ,members)))))

(defun foreign-structure-member (%pointer type-name member-name
                                 &optional (offset 0))
  (let* ((type (foreign-type type-name))
         (member (find-foreign-structure-member member-name type)))
    (foreign-value (%pointer+ %pointer
                              (foreign-structure-member-offset member))
                   (foreign-structure-member-type member)
                   offset)))

(define-compiler-macro foreign-structure-member (&whole form
                                                 %pointer type-name member-name
                                                 &optional (offset 0))
  (cond
    ((and (listp type-name)
          (eq (car type-name) 'cl:quote)
          (symbolp (cadr type-name))
          (constantp member-name))
     (let* ((type (foreign-type (cadr type-name)))
            (member (find-foreign-structure-member member-name type))
            (member-type (foreign-structure-member-type member)))
       `(foreign-value (%pointer+ ,%pointer
                                  ,(foreign-structure-member-offset member))
                       ,(if (keywordp member-type) member-type `',member-type)
                       ,offset)))
    (t
     form)))

(defun write-foreign-structure-member (%pointer type-name member-name
                                       offset value)
  (let* ((type (foreign-type type-name))
         (member (find-foreign-structure-member member-name type)))
    (setf (foreign-value (%pointer+ %pointer
                                    (foreign-structure-member-offset member))
                         (foreign-structure-member-type member)
                         offset)
          value)))

(define-compiler-macro write-foreign-structure-member (&whole form
                                                       %pointer type-name
                                                       member-name offset
                                                       value)
  (cond
    ((and (listp type-name)
          (eq (car type-name) 'cl:quote)
          (symbolp (cadr type-name))
          (constantp member-name))
     (let* ((type (foreign-type (cadr type-name)))
            (member (find-foreign-structure-member member-name type))
            (member-type (foreign-structure-member-type member)))
       `(setf (foreign-value
               (%pointer+ ,%pointer ,(foreign-structure-member-offset member))
               ,(if (keywordp member-type)
                    member-type
                    `',member-type)
               ,offset)
              ,value)))
    (t
     form)))

(defsetf foreign-structure-member (%pointer type-name member-name
                                   &optional (offset 0))
    (value)
  `(write-foreign-structure-member ,%pointer ,type-name ,member-name
     ,offset ,value))

(defun foreign-structure-member-pointer (%pointer type-name member-name
                                         &optional (offset 0))
  (let* ((type (foreign-type type-name))
         (member (find-foreign-structure-member member-name type)))
    (%pointer+ %pointer
               (+ (foreign-structure-member-offset member)
                  (* offset (foreign-type-size
                             (foreign-structure-member-type member)))))))

(define-compiler-macro foreign-structure-member-pointer (&whole form
                                                         %pointer type-name
                                                         member-name
                                                         &optional (offset 0))
  (cond
    ((and (listp type-name)
          (eq (car type-name) 'cl:quote)
          (symbolp (cadr type-name))
          (constantp member-name))
     (let* ((type (foreign-type (cadr type-name)))
            (member (find-foreign-structure-member member-name type))
            (member-type (foreign-structure-member-type member)))
       `(%pointer+
         ,%pointer
         ,(if (constantp offset)
              (+ (foreign-structure-member-offset member)
                 (* offset (foreign-type-size member-type)))
              `(+ ,(foreign-structure-member-offset member)
                  (* ,offset ,(foreign-type-size member-type)))))))
    (t
     form)))

(defmacro with-foreign-structure-members ((bindings %pointer type-name)
                                          &body body)
  `(symbol-macrolet
       (,@(mapcar
            (lambda (binding)
              (destructuring-bind (var member-name &key offset) binding
                `(,var (foreign-structure-member ,%pointer ,type-name
                                                 ,member-name
                                                 ,@(when offset
                                                     `(:offset ,offset))))))
            bindings))
     ,@body))
