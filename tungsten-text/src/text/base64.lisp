(in-package :text)

(define-condition invalid-base64-character (error)
  ((character
    :type character
    :initarg :character
    :reader invalid-base64-character-character))
  (:report
   (lambda (condition stream)
     (format stream "invalid base64 character ~S"
             (invalid-base64-character-character condition)))))

(defun encode-base64 (octets &key (start 0) (end (length octets)))
  (declare (type core:octet-vector octets)
           (type (integer 0) start end))
  (do ((string (make-array (* (ceiling (- end start) 3) 4)
                           :element-type 'standard-char))
       (alphabet
        "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/")
       (i start (+ i 3))
       (j 0 (+ j 4)))
      ((>= i end)
       string)
    (let* ((group-size (the (integer 1 3) (min 3 (- end i))))
           (o1 (aref octets i))
           (o2 (if (> group-size 1) (aref octets (+ i 1)) 0))
           (o3 (if (> group-size 2) (aref octets (+ i 2)) 0))
           (c1 (the (signed-byte 6) 0))
           (c2 (the (signed-byte 6) 0))
           (c3 (the (signed-byte 6) 0))
           (c4 (the (signed-byte 6) 0)))
      (setf (ldb (byte 6 0) c1) (ldb (byte 6 2) o1)
            (char string j) (char alphabet c1))
      (setf (ldb (byte 2 4) c2) (ldb (byte 2 0) o1)
            (ldb (byte 4 0) c2) (ldb (byte 4 4) o2)
            (char string (+ j 1)) (char alphabet c2))
      (setf (ldb (byte 4 2) c3) (ldb (byte 4 0) o2)
            (ldb (byte 2 0) c3) (ldb (byte 2 6) o3)
            (char string (+ j 2))
            (if (< group-size 2) #\= (char alphabet c3)))
      (setf (ldb (byte 6 0) c4) (ldb (byte 6 0) o3)
            (char string (+ j 3))
            (if (< group-size 3) #\= (char alphabet c4))))))

(defun decode-base64 (string &key (start 0) (end (length string)))
  (declare (type string string)
           (type (integer 0) start end))
  (flet ((base64-character-value (character)
           (cond
             ((char<= #\A character #\Z)
              (- (char-code character) #.(char-code #\A)))
             ((char<= #\a character #\z)
              (+ 26 (- (char-code character) #.(char-code #\a))))
             ((char<= #\0 character #\9)
              (+ 52 (- (char-code character) #.(char-code #\0))))
             ((char= character #\+)
              62)
             ((char= character #\/)
              63)
             (t
              (error 'invalid-base64-character :character character)))))
    (let ((nb-octets (* (ceiling (- end start) 4) 3)))
      (when (and (> end start) (char= (aref string (- end 1)) #\=))
        (decf end)
        (decf nb-octets)
        (when (and (> end start) (char= (aref string (- end 1)) #\=))
          (decf end)
          (decf nb-octets)))
      (do ((octets (core:make-octet-vector nb-octets))
           (i start (+ i 4))
           (j 0 (+ j 3)))
          ((>= i end)
           octets)
        (let* ((group-size (the (integer 1 4) (min 4 (- end i))))
               (c1 (base64-character-value (char string i)))
               (c2 (if (> group-size 1)
                       (base64-character-value (char string (+ i 1)))
                       0))
               (c3 (if (> group-size 2)
                       (base64-character-value (char string (+ i 2)))
                       0))
               (c4 (if (> group-size 3)
                       (base64-character-value (char string (+ i 3)))
                       0))
               (o1 0)
               (o2 0)
               (o3 0))
          (setf (ldb (byte 6 2) o1) (ldb (byte 6 0) c1)
                (ldb (byte 2 0) o1) (ldb (byte 2 4) c2)
                (aref octets j) o1)
          (when (> group-size 2)
            (setf (ldb (byte 4 4) o2) (ldb (byte 4 0) c2)
                  (ldb (byte 4 0) o2) (ldb (byte 4 2) c3)
                  (aref octets (+ j 1)) o2))
          (when (> group-size 3)
            (setf (ldb (byte 2 6) o3) (ldb (byte 2 0) c3)
                  (ldb (byte 6 0) o3) (ldb (byte 6 0) c4)
                  (aref octets (+ j 2)) o3)))))))
